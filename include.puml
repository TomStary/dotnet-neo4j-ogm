@startuml DBSet Diagram
interface ISession {
    SaveAsync(entity:TEntity) : Task
    Set(entity:TEntity) : DbSet<TEntity>
}
IDisposable <|-- ISession
class "DbSet`1"<TEntity> {
    + DbSet(session:ISession)
    + <<virtual>> FindAsync(keyValues:object?[]?) : Task<TEntity?>
}

class OGMIQueryableExtensions <<static>> {
    + {static} FirstOrDefaultAsync(query:IQueryable<TSource>, predicate:Expression<Func<TSource, bool>>) : Task<TSource?>
}
interface IStatementFactory {
    CreateStatement(statement:string, parameters:Dictionary<string, object>) : IStatement
}
class RowDataStatement {
    + Statement : string <<get>>
    + RowDataStatement(statement:string, parameters:Dictionary<string, object?>)
}
class "Dictionary`2"<T1,T2> {
}
IStatement <|-- RowDataStatement
RowDataStatement --> "Parameters<string,object?>" "Dictionary`2"
interface IStatement {
    Statement : string <<get>>
}
class "Dictionary`2"<T1,T2> {
}
IStatement --> "Parameters<string,object?>" "Dictionary`2"
class RelationshipEntityAttribute {
    + Type : string <<get>>
    + RelationshipEntityAttribute(type:string)
}
Attribute <|-- RelationshipEntityAttribute
class StartNodeAttribute {
}
Attribute <|-- StartNodeAttribute
class EndNodeAttribute {
}
Attribute <|-- EndNodeAttribute
class RelationshipAttribute {
    + Type : string <<get>>
    + RelationshipAttribute(type:string, direction:DirectionEnum)
}
enum DirectionEnum {
    Outgoing,
    Incoming,
    Undirected,
}
Attribute <|-- RelationshipAttribute
RelationshipAttribute --> "Direction" DirectionEnum
RelationshipAttribute +-- DirectionEnum
class NodeAttribute {
    + Label : string <<get>>
    + NodeAttribute(label:string)
}
Attribute <|-- NodeAttribute
class Session {
    + Session(metadata:MetaData, driver:IDriver)
    + Session(connectionString:string, assemblies:Assembly[])
    + SaveAsync(entity:TEntity) : Task
    + Set(entity:TEntity) : DbSet<TEntity>
    + Dispose() : void
}
ISession <|-- Session
class SessionSaveDelegate {
}
interface IAsyncQueryProvider {
    ExecuteAsync(expression:Expression) : TResult
}
IQueryProvider <|-- IAsyncQueryProvider
class QueryableMethods <<static>> {
    {static} QueryableMethods()
}
QueryableMethods --> "FirstOrDefaultWithPredicate" MethodInfo
class EntityQueryProvider {
    + EntityQueryProvider(session:ISession)
    + CreateQuery(expression:Expression) : IQueryable
    + CreateQuery(expression:Expression) : IQueryable<TElement>
    + Execute(expression:Expression) : object?
    + Execute(expression:Expression) : TResult
    + ExecuteAsync(expression:Expression) : TResult
}
IAsyncQueryProvider <|-- EntityQueryProvider
class MetaData {
    + MetaData(assemblies:Assembly[])
}
MetaData --> "Schema" ISchema
class DomainInfo {
    + DomainInfo(assemblies:Assembly[])
}
class "Dictionary`2"<T1,T2> {
}
DomainInfo --> "NodeClasses<string,Type>" "Dictionary`2"
DomainInfo --> "RelationshipClasses<string,Type>" "Dictionary`2"
class NodeModel {
    + Label : string <<get>>
    + NodeModel(id:long)
}
class "IEnumerable`1"<T> {
}
NodeModel --> "Labels<string>" "IEnumerable`1"
interface IRowModel {
    GetValues() : object[]
    Variables() : string[]
}
class NodeBuilder {
    + NodeBuilder(id:long)
    + AddLabels(labels:IEnumerable<string>) : NodeBuilder
    + AddProperty(name:string, value:object?) : void
}
NodeBuilder --> "Node" NodeModel
class CompilerContext {
    + CompilerContext(compiler:MultiStatementCypherCompiler)
    + VisitedNode(entity:object) : NodeBuilder?
    + Visited(entity:object, horizon:int) : bool
    + VisitedRelationshipEntity(id:long) : bool
    + RegisterNewObject(id:long, entity:object) : void
    + Register(entity:object) : void
    + Unregister(entity:object) : void
}
class NodeBuilderHorizonPair {
}
ICompilerContext <|-- CompilerContext
CompilerContext --> "Compiler" MultiStatementCypherCompiler
CompilerContext +-- NodeBuilderHorizonPair
class Edge {
}
interface ICompilerContext {
    Register(entity:object) : void
    RegisterNewObject(id:long, entity:object) : void
    Unregister(entity:object) : void
    Visited(entity:object, horizon:int) : bool
    VisitedNode(entity:object) : NodeBuilder?
    VisitedRelationshipEntity(id:long) : bool
}
ICompilerContext --> "Compiler" MultiStatementCypherCompiler
class RelationshipBuilder {
    + Singleton : bool <<get>> <<internal set>>
    + Reference : long <<get>> <<internal set>>
    + RelationshipEntity : bool <<get>> <<internal set>>
    + Type : string <<get>>
    + RelationshipBuilder(type:string, mapBothDirections:bool)
    + RelationshipBuilder(type:string, relId:long)
}
class MultiStatementCypherCompiler {
    + MultiStatementCypherCompiler()
    + UseStatementFactory(statementFactory:IStatementFactory) : void
    + CreateNode(id:long) : NodeBuilder
    + ExistingNode(id:long) : NodeBuilder
}
MultiStatementCypherCompiler --> "Context" CompilerContext
class QueryCompiler {
    + <<virtual>> ExecuteAsync(query:Expression) : TResult
}
class ExpressionExtensions <<static>> {
}
interface ITransactionManager {
    CreateTransaction() : ITransaction
    CurrentTransaction() : ITransaction
    Commit(transaction:ITransaction) : void
    Rollback(transaction:ITransaction) : void
}
class TransactionManager {
    + Commit(transaction:ITransaction) : void
    + CreateTransaction() : ITransaction
    + CurrentTransaction() : ITransaction
    + Rollback(transaction:ITransaction) : void
}
ITransactionManager <|-- TransactionManager
interface ITransaction {
    Commit() : void
    Rollback() : void
    GetStatus() : Status
}
enum Status {
    OPEN,
    PENDING,
    ROLLEDBACK,
    COMMITTED,
    CLOSED,
    ROLEBACK_PENDING,
    COMMIT_PENDING,
}
ITransaction +-- Status
class TypeExtensions <<static>> {
}
class DictionaryExtensions <<static>> {
}
interface IRelationship {
    Type : string <<get>>
    Start() : INode
    Other(node:INode) : INode
}
IRelationship --> "Direction" DirectionEnum
interface INode {
    Label : string? <<get>>
    AddRelationship(type:string, relationship:IRelationship) : void
}
class "Dictionary`2"<T1,T2> {
}
INode --> "Relationships<string,IRelationship>" "Dictionary`2"
class SchemaBuilder {
    + SchemaBuilder(domainInfo:DomainInfo)
    + Build() : ISchema
}
class Relationship {
    + Type : string <<get>> <<init>>
    + Relationship(type:string, direction:RelationshipAttribute.DirectionEnum, start:INode, end:INode)
    + Other(node:INode) : INode
    + Start() : INode
}
IRelationship <|-- Relationship
Relationship --> "StartNode" INode
Relationship --> "EndNode" INode
class Node {
    + Label : string? <<get>> <<init>>
    + Node(label:string?)
    + AddRelationship(type:string, relationship:IRelationship) : void
}
class "Dictionary`2"<T1,T2> {
}
INode <|-- Node
Node --> "Relationships<string,IRelationship>" "Dictionary`2"
interface ISchema {
    FindNode(label:string) : INode
    FindRelationship(type:string) : IRelationship
}
class SchemaObj {
    + SchemaObj()
    + FindNode(label:string) : INode
    + FindRelationship(type:string) : IRelationship
}
ISchema <|-- SchemaObj
class NewNodeStatementBuilder {
    + NewNodeStatementBuilder(newNodes:List<NodeModel>, statementFactory:IStatementFactory)
    + Build() : IStatement
}
@enduml
