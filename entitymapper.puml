@startuml
!theme vibrant
interface IEntityMapper {
    Map(entity:object, depth:int) : ICompilerContext
    CompilerContext() : ICompilerContext
}
class EntityGraphMapper {
    + EntityGraphMapper(metadata:MetaData, mappingContext:MappingContext)
    + Map(entity:object, depth:int) : ICompilerContext
    + CompilerContext() : ICompilerContext
}
IEntityMapper <|-- EntityGraphMapper

interface ICompilerContext {
    Register(entity:object) : void
    RegisterNewObject(id:long, entity:object) : void
    Unregister(entity:object) : void
    Visited(entity:object, horizon:int) : bool
    VisitedNode(entity:object) : NodeBuilder?
    VisitedRelationshipEntity(id:long) : bool
}
class CompilerContext {
    + CompilerContext(compiler:MultiStatementCypherCompiler)
    + VisitedNode(entity:object) : NodeBuilder?
    + Visited(entity:object, horizon:int) : bool
    + VisitedRelationshipEntity(id:long) : bool
    + RegisterNewObject(id:long, entity:object) : void
    + Register(entity:object) : void
    + Unregister(entity:object) : void
}

ICompilerContext <|-- CompilerContext

' IQueryProvider <|-- IAsyncQueryProvider
' class QueryableMethods <<static>> {
'     {static} QueryableMethods()
' }
' QueryableMethods --> "FirstOrDefaultWithPredicate" MethodInfo
' class EntityQueryProvider {
'     + EntityQueryProvider(session:ISession)
'     + CreateQuery(expression:Expression) : IQueryable
'     + CreateQuery(expression:Expression) : IQueryable<TElement>
'     + Execute(expression:Expression) : object?
'     + Execute(expression:Expression) : TResult
'     + ExecuteAsync(expression:Expression) : TResult
' }
' IAsyncQueryProvider <|-- EntityQueryProvider
' class MetaData {
'     + MetaData(assemblies:Assembly[])
' }
' MetaData --> "Schema" ISchema
' class DomainInfo {
'     + DomainInfo(assemblies:Assembly[])
' }
' class "Dictionary`2"<T1,T2> {
' }
' DomainInfo --> "NodeClasses<string,Type>" "Dictionary`2"
' DomainInfo --> "RelationshipClasses<string,Type>" "Dictionary`2"
' class NodeModel {
'     + Label : string <<get>>
'     + NodeModel(id:long)
' }
' class "IEnumerable`1"<T> {
' }
' NodeModel --> "Labels<string>" "IEnumerable`1"
' interface IRowModel {
'     GetValues() : object[]
'     Variables() : string[]
' }
' class NodeBuilder {
'     + NodeBuilder(id:long)
'     + AddLabels(labels:IEnumerable<string>) : NodeBuilder
'     + AddProperty(name:string, value:object?) : void
' }
' NodeBuilder --> "Node" NodeModel

' class NodeBuilderHorizonPair {
' }
' ICompilerContext <|-- CompilerContext
' CompilerContext --> "Compiler" MultiStatementCypherCompiler
' CompilerContext +-- NodeBuilderHorizonPair
' class Edge {
' }
' interface ICompilerContext {
'     Register(entity:object) : void
'     RegisterNewObject(id:long, entity:object) : void
'     Unregister(entity:object) : void
'     Visited(entity:object, horizon:int) : bool
'     VisitedNode(entity:object) : NodeBuilder?
'     VisitedRelationshipEntity(id:long) : bool
' }
' ICompilerContext --> "Compiler" MultiStatementCypherCompiler
' class RelationshipBuilder {
'     + Singleton : bool <<get>> <<internal set>>
'     + Reference : long <<get>> <<internal set>>
'     + RelationshipEntity : bool <<get>> <<internal set>>
'     + Type : string <<get>>
'     + RelationshipBuilder(type:string, mapBothDirections:bool)
'     + RelationshipBuilder(type:string, relId:long)
' }
' class MultiStatementCypherCompiler {
'     + MultiStatementCypherCompiler()
'     + UseStatementFactory(statementFactory:IStatementFactory) : void
'     + CreateNode(id:long) : NodeBuilder
'     + ExistingNode(id:long) : NodeBuilder
' }
' class QueryCompiler {
'     + <<virtual>> ExecuteAsync(query:Expression) : TResult
' }
' interface ITransactionManager {
'     CreateTransaction() : ITransaction
'     CurrentTransaction() : ITransaction
'     Commit(transaction:ITransaction) : void
'     Rollback(transaction:ITransaction) : void
' }
' class TransactionManager {
'     + Commit(transaction:ITransaction) : void
'     + CreateTransaction() : ITransaction
'     + CurrentTransaction() : ITransaction
'     + Rollback(transaction:ITransaction) : void
' }
' ITransactionManager <|-- TransactionManager
' interface ITransaction {
'     Commit() : void
'     Rollback() : void
'     GetStatus() : Status
' }
' enum Status {
'     OPEN,
'     PENDING,
'     ROLLEDBACK,
'     COMMITTED,
'     CLOSED,
'     ROLEBACK_PENDING,
'     COMMIT_PENDING,
' }
' ITransaction +-- Status
' interface IRelationship {
'     Type : string <<get>>
'     Start() : INode
'     Other(node:INode) : INode
' }
' IRelationship --> "Direction" DirectionEnum
' interface INode {
'     Label : string? <<get>>
'     AddRelationship(type:string, relationship:IRelationship) : void
' }
' class "Dictionary`2"<T1,T2> {
' }
' INode --> "Relationships<string,IRelationship>" "Dictionary`2"
' class SchemaBuilder {
'     + SchemaBuilder(domainInfo:DomainInfo)
'     + Build() : ISchema
' }
' class Relationship {
'     + Type : string <<get>> <<init>>
'     + Relationship(type:string, direction:RelationshipAttribute.DirectionEnum, start:INode, end:INode)
'     + Other(node:INode) : INode
'     + Start() : INode
' }
' IRelationship <|-- Relationship
' Relationship --> "StartNode" INode
' Relationship --> "EndNode" INode
' class Node {
'     + Label : string? <<get>> <<init>>
'     + Node(label:string?)
'     + AddRelationship(type:string, relationship:IRelationship) : void
' }
' class "Dictionary`2"<T1,T2> {
' }
' INode <|-- Node
' Node --> "Relationships<string,IRelationship>" "Dictionary`2"
' interface ISchema {
'     FindNode(label:string) : INode
'     FindRelationship(type:string) : IRelationship
' }
' class SchemaObj {
'     + SchemaObj()
'     + FindNode(label:string) : INode
'     + FindRelationship(type:string) : IRelationship
' }
' ISchema <|-- SchemaObj
' class NewNodeStatementBuilder {
'     + NewNodeStatementBuilder(newNodes:List<NodeModel>, statementFactory:IStatementFactory)
'     + Build() : IStatement
' }
@enduml
